1.jvm内存模型：
线程私有 虚拟机栈、本地方法栈、程序计数器
线程共享 堆、方法区

2.类加载机制：
双亲委派 防止重复加载、安全性
根类-》扩展类-》系统类-》自定义类

3.一个对象从出生到死亡的过程：
虚拟机得到new指令，判断该类的符号引用是否存在（不存在则重新加载）
类加载完成，堆上为对象分配内存
内存分配完成，将对应内存空间设置为零值
设置对象头
初始化对象

4.新生代和老年代gc算法：
新生代 复制算法 eden区和两个survivor区 比例是8:1:1 每当新建一个对象而eden区内存不足时 进行minorGC eden区活着的对象会复制到to survivor区 from survivor
区中年龄超过阈值的对象会保存到老年代中 没有超过的保存到to survivor区 然后to from互换位置 某些大对象会直接放入老年代（避免性能消耗）
老年代 标记整理算法 进行minorGC之前 检查老年代最大连续可用空间是否大于新生代历次晋升到老年代的平均大小 若大于 则执行minorGC 否则执行fullGC

5.调用自己类中的cacheable方法为什么会失效：
cacheable基于aop 调用自己类中的cacheable方法不会走aop 因此失败

6.ioc和di：
ioc 控制翻转
di 依赖注入
通过依赖注入去实现了控制翻转

7.springboot如何实现自动配置：
启动springboot需要添加@springbootApplication注解 这个注解包含了@enableAutoConfiguration注解 这个注解会启动自动配置 到spring.factories文件下加载
自动配置类文件和对应的properties类 实现信息的自动配置

8.spring依赖注入的三种方式：
变量注入
构造器注入
setter注入

9.循环依赖问题：
三级缓存

10.项目中怎么实用aop：
日志切面
